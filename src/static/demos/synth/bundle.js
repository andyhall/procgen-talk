/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "../demo/demo.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../demo/clickGridView.js":
/*!********************************!*\
  !*** ../demo/clickGridView.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ClickGridView);\n\n\n\n\nfunction ClickGridView(canvasElement, range, list) {\n    this.canvas = canvasElement\n    this.ctx = this.canvas.getContext('2d')\n    this.canvas.addEventListener('click', ev => { onClick(ev, this) })\n\n    this.range = range || 2\n    this.onChange = () => { }\n    this.rules = list || [[0, 1], [1, 0]]\n\n    this.draw()\n}\n\n\n\n\n\n/*\n * \n *      update and conform rules list\n * \n*/\n\nfunction onClick(ev, self) {\n    var s = 2 * self.range + 1\n    var i = (s * ev.offsetX / self.canvas.width) | 0\n    var j = (s * ev.offsetY / self.canvas.height) | 0\n    var off = [i - self.range, j - self.range]\n    if (off.join() === '0,0') return\n    var removing = -1\n    self.rules.forEach((noff, i) => {\n        if (off.join() === noff.join()) removing = i\n    })\n    if (removing >= 0) {\n        self.rules.splice(removing, 1)\n    } else {\n        self.rules.push(off)\n    }\n    self.draw()\n    self.onChange()\n}\n\n\n\n\n\n/*\n * \n *      draw whatever's in the rules list\n * \n*/\n\nClickGridView.prototype.draw = function () {\n    var w = this.canvas.width\n    var s = 2 * this.range + 1\n    var gs = (w / s) | 0\n    this.canvas.width = s * gs\n    this.canvas.height = s * gs\n\n    for (var i = 0; i < s; i++) {\n        for (var j = 0; j < s; j++) {\n            var x = i - this.range\n            var y = j - this.range\n            var state = (x === 0 && y === 0) ? 2 : 0\n            drawRect(this.ctx, state, i * gs, j * gs, gs, gs)\n        }\n    }\n\n    this.rules.forEach(off => {\n        var i = this.range + off[0]\n        var j = this.range + off[1]\n        drawRect(this.ctx, 1, i * gs, j * gs, gs, gs)\n    })\n}\n\n\nfunction drawRect(ctx, state, x, y, w, h) {\n    w--\n    h--\n    // clear out\n    ctx.strokeStyle = '#999'\n    ctx.fillStyle = 'white'\n    ctx.strokeRect(x, y, w, h)\n    ctx.fillRect(x, y, w, h)\n\n    var s = 3\n    if (state === 1) {\n        ctx.fillStyle = '#666'\n        ctx.fillRect(x + s, y + s, w - s * 2, h - s * 2)\n    }\n\n    s = 4\n    if (state === 2) {\n        ctx.fillStyle = 'red'\n        ctx.fillRect(x + s, y + s, w - s * 2, h - s * 2)\n    }\n}\n\n\n\n\n\n\n\n//# sourceURL=webpack:///../demo/clickGridView.js?");

/***/ }),

/***/ "../demo/demo.js":
/*!***********************!*\
  !*** ../demo/demo.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _presets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./presets */ \"../demo/presets.js\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ndarray */ \"../node_modules/ndarray/ndarray.js\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui */ \"../demo/ui.js\");\n/* harmony import */ var _src_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/util */ \"../src/util.js\");\n/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/index */ \"../src/index.js\");\n\n\n\n\n\n\n\n\ninitProfiling(true)\n\n\n\n\n\n/*\n * \n *      synth settings and update functions\n * \n*/\n\nvar synth\nvar input\nvar output = new ndarray__WEBPACK_IMPORTED_MODULE_1__([], [50, 50])\nvar options = {\n    symmetry: [false, false],\n    edges: 'wrap',\n    propagateDepth: 1,\n    filterRules: [\n        // [0, -1],\n        // [1, 0],\n    ],\n    filterSymmetry: [false, false],\n}\nvar rules = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n]\n\nfunction setPreset(i) {\n    var preset = _presets__WEBPACK_IMPORTED_MODULE_0__[\"default\"][i]\n    _ui__WEBPACK_IMPORTED_MODULE_2__[\"setColors\"](preset.colors)\n    input = preset.data\n    if (preset.symmetry) {\n        options.symmetry[0] = !!preset.symmetry[0]\n        options.symmetry[1] = !!preset.symmetry[1]\n        _ui__WEBPACK_IMPORTED_MODULE_2__[\"setSymmetry\"](options.symmetry)\n    }\n    if (preset.edges) {\n        options.edges = preset.edges\n        _ui__WEBPACK_IMPORTED_MODULE_2__[\"setEdges\"](options.edges)\n    }\n    reset()\n}\n\nfunction setSymmetry(x, y) {\n    if (x !== undefined) options.symmetry[0] = x\n    if (y !== undefined) options.symmetry[1] = y\n    reset()\n}\n\nfunction setFilterSymmetry(x, y) {\n    if (x !== undefined) options.filterSymmetry[0] = x\n    if (y !== undefined) options.filterSymmetry[1] = y\n    reset()\n}\n\nfunction setEdges(val) {\n    options.edges = val\n    reset()\n}\n\nfunction setOutputSize(s) {\n    output = new ndarray__WEBPACK_IMPORTED_MODULE_1__([], [s, s])\n    reset()\n}\n\nfunction setDepth(d) {\n    options.propagateDepth = parseInt(d)\n    reset()\n}\n\nfunction setRules(list, filtList) {\n    rules = list\n    options.filterRules = filtList\n    reset()\n}\n\n\n\n\n/*\n * \n *      core\n * \n*/\n\nfunction reset() {\n    synth = new _src_index__WEBPACK_IMPORTED_MODULE_4__[\"default\"](input, output, rules, options)\n    _ui__WEBPACK_IMPORTED_MODULE_2__[\"drawImage\"]('input', input)\n    _ui__WEBPACK_IMPORTED_MODULE_2__[\"drawImage\"]('filtered', synth.filteredInput)\n    solve()\n}\n\nfunction drawPartialOutput() {\n    Object(_src_util__WEBPACK_IMPORTED_MODULE_3__[\"iterate2D\"])(output, (i, j) => {\n        var weights = synth.getNodeWeights(i, j)\n        _ui__WEBPACK_IMPORTED_MODULE_2__[\"updatePixel\"]('output', i, j, weights)\n        var fweights = synth.getFilteredNodeWeights(i, j)\n        _ui__WEBPACK_IMPORTED_MODULE_2__[\"updatePixel\"]('filtered-out', i, j, fweights)\n    })\n}\n\nfunction iterate(maxSteps) {\n    var partial = (maxSteps > 0)\n    if (synth.done) {\n        synth.reset()\n        profile('init')\n    }\n    if (partial) {\n        while (!synth.done && (maxSteps-- > 0)) {\n            synth.iterate()\n            profile('step')\n        }\n        drawPartialOutput()\n        profile('draw')\n    } else {\n        while (!synth.done) synth.iterate()\n        profile('solve')\n        _ui__WEBPACK_IMPORTED_MODULE_2__[\"drawImage\"]('output', output)\n        _ui__WEBPACK_IMPORTED_MODULE_2__[\"drawImage\"]('filtered-out', synth.filteredOutput)\n        profile('draw')\n        report()\n    }\n}\n\n\nfunction solve() {\n    profile('start')\n    iterate(0)\n    profile('end')\n    animating = false\n}\n\n\nfunction step(n) {\n    profile('start')\n    iterate(n || 1)\n    profile('end')\n    if (synth.done) animating = false\n    if (animating) requestAnimationFrame(() => step(animateSteps))\n}\n\nvar animating = false\nvar animateSteps = 1\nfunction setAnimate(on) {\n    animating = !!on\n    if (on) step(animateSteps)\n}\n\n\nfunction report() {\n    if (!synth.done) return ''\n    var fn = (acc, v) => { acc[v] = (acc[v] || 0) + 1; return acc }\n    var inct = input.data.reduce(fn, []).map(n => n / input.data.length)\n    var outct = output.data.reduce(fn, []).map(n => n / output.data.length)\n    var diffs = inct.map((v, i) => Math.abs(v - (outct[i] || 0)) / v)\n    var qual = 100 - 100 * diffs.reduce((acc, d) => acc + d, 0) / diffs.length\n    return 'freq match: ' + Math.round(qual) + '%'\n}\n\n\n\n\n\n\n\n// start by initting and solving preset\nsetPreset(3)\n\n\n\n\n\n\n\n/*\n * \n *      give UI some initial values\n *      and handle some UI events\n * \n*/\n\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"initPresetNames\"](_presets__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map(o => o.name))\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"initOutputSize\"](output.shape[0])\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"setRules\"](rules, options.filterRules)\n\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('preset', ix => setPreset(ix))\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('xSymmetry', val => setSymmetry(val, undefined))\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('ySymmetry', val => setSymmetry(undefined, val))\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('edges', setEdges)\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('size', setOutputSize)\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('xFilterSym', val => setFilterSymmetry(val, undefined))\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('yFilterSym', val => setFilterSymmetry(undefined, val))\n\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('solve', solve)\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('step', () => step())\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('anim', (on) => setAnimate(on))\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('animSteps', (n) => animateSteps = n)\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('misc', solve)\n\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('rules', setRules)\n_ui__WEBPACK_IMPORTED_MODULE_2__[\"listen\"]('propDepth', setDepth)\n\n\n\n\n\n// profiling\nvar profile\nfunction initProfiling(enabled) {\n    var log = s => _ui__WEBPACK_IMPORTED_MODULE_2__[\"log\"](s + '\\n' + report())\n    profile = (enabled) ? Object(_src_util__WEBPACK_IMPORTED_MODULE_3__[\"makeTimer\"])(1, 'synth', log) : () => { }\n}\n\n\n\n//# sourceURL=webpack:///../demo/demo.js?");

/***/ }),

/***/ "../demo/imageView.js":
/*!****************************!*\
  !*** ../demo/imageView.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/util */ \"../src/util.js\");\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ImageView);\n\n\n// settings\nvar baseScale = 10\nvar minSize = 100\nvar maxSize = 300\nvar defaultColors = [\n    [255, 255, 255],\n    [0, 0, 0],\n    [255, 0, 0],\n    [0, 255, 0],\n    [0, 0, 255],\n    [0, 255, 255],\n    [255, 0, 255],\n    [255, 255, 0],\n]\n\n\n\nfunction ImageView(canvasElement) {\n    this.canvas = canvasElement\n    this.ctx = this.canvas.getContext('2d')\n    this.colors = defaultColors\n    this.displayScale = 1\n    this._scale = 5\n}\n\n\n\n\n\nImageView.prototype.drawData = function (data) {\n    var s = baseScale\n    var minShape = Math.min(data.shape[0], data.shape[1])\n    var maxShape = Math.max(data.shape[0], data.shape[1])\n    if (s * minShape < minSize) s = minSize / minShape\n    if (s * maxShape > maxSize) s = maxSize / maxShape\n    s = Math.max(1, s | 0)\n    s *= this.displayScale\n    this._scale = s\n\n    var cols = this.colors || defaultColors\n    this.canvas.width = s * data.shape[0]\n    this.canvas.height = s * data.shape[1]\n\n    Object(_src_util__WEBPACK_IMPORTED_MODULE_0__[\"iterate2D\"])(data, (i, j) => {\n        var val = data.get(i, j)\n        var color = cols[val] || makeColor(val)\n        this.ctx.fillStyle = `rgb(${color.join()})`\n        this.ctx.fillRect(i * s, j * s, s, s)\n    })\n}\n\n\n\nImageView.prototype.updatePixel = function (i, j, weights) {\n    var s = this._scale\n    var cols = this.colors || defaultColors\n    var wtSum = 0\n    var colSum = weights.reduce((acc, wt, ix, arr) => {\n        if (wt === 0) return acc\n        wtSum += wt\n        var col = cols[ix] || makeColor(ix)\n        col.forEach((v, i) => { acc[i] += v * wt })\n        return acc\n    }, [0, 0, 0])\n    var rgb = colSum.map(n => (n / wtSum) | 0)\n    this.ctx.fillStyle = `rgb(${rgb.join()})`\n    this.ctx.fillRect(i * s, j * s, s, s)\n}\n\n\n\n\n/*\n * \n *      ad-hoc fn for unset color values\n * \n*/\n\nfunction makeColor(i) {\n    return [\n        (i * 143) & 0xFF,\n        (i * 157) & 0xFF,\n        (i * 179) & 0xFF,\n    ]\n}\n\n\n\n\n//# sourceURL=webpack:///../demo/imageView.js?");

/***/ }),

/***/ "../demo/presets.js":
/*!**************************!*\
  !*** ../demo/presets.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ndarray */ \"../node_modules/ndarray/ndarray.js\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _src_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/util */ \"../src/util.js\");\n\n\n\n\nvar presets = []\n\n\n/*\n * \n * \n *      raw preset definitions\n * \n * \n*/\n\n\n\n\npresets.push({\n    name: 'ground',\n    layout: [\n        '        ',\n        '        ',\n        '   22   ',\n        '   22   ',\n        '        ',\n        '        ',\n        '111111111',\n    ],\n    edges: 'clamp',\n})\n\n\npresets.push({\n    name: 'boxes',\n    layout: [\n        '                 ',\n        '                 ',\n        '                 ',\n        '          111    ',\n        '   11     111    ',\n        '   11     111    ',\n        '                 ',\n        '                 ',\n    ],\n    edges: 'wrap',\n})\n\n\n\npresets.push({\n    name: 'filtered boxes',\n    layout: [\n        '                   ',\n        '                   ',\n        '          12223    ',\n        '  1223    12223    ',\n        '  1223    12223    ',\n        '  1223    12223    ',\n        '  1223    12223    ',\n        '                   ',\n        '                   ',\n    ],\n    edges: 'wrap',\n})\n\n\n\npresets.push({\n    name: 'Lines',\n    layout: [\n        '  1  ',\n        '  1  ',\n        '22222',\n        '  1  ',\n        '  1  ',\n    ],\n})\n\n\n\n\npresets.push({\n    name: 'Columns',\n    layout: [\n        '  1   2  ',\n        '  1   2  ',\n        '  1   2  ',\n        '  1   2  ',\n        '  1   2  ',\n    ],\n})\n\npresets.push({\n    name: 'Sym test H',\n    layout: [\n        '  12  ',\n        '  12  ',\n        '  12  ',\n        '  12  ',\n    ],\n    symmetry: [1, 0],\n})\n\n\npresets.push({\n    name: 'Sym test V',\n    layout: [\n        '    ',\n        '    ',\n        '1111',\n        '2222',\n        '    ',\n        '    ',\n    ],\n    symmetry: [0, 1],\n})\n\n\npresets.push({\n    name: 'maze',\n    layout: [\n        '    ',\n        ' 111',\n        ' 1 1',\n        ' 111',\n    ],\n    symmetry: [1, 1],\n})\n\n\npresets.push({\n    name: 'red maze',\n    layout: [\n        '    ',\n        ' 111',\n        ' 121',\n        ' 111',\n    ],\n    symmetry: [1, 1],\n})\n\n\n\npresets.push({\n    name: 'rooms',\n    layout: [\n        '111 11111111 111',\n        '111 11111      1',\n        '1     111      1',\n        '1     111      1',\n        '1              1',\n        '      111       ',\n        '1     111      1',\n        '11 11111111 1111',\n        '11 11111111 1111',\n        '11 11111111 1111',\n        '11     111    11',\n        '       111      ',\n        '11            11',\n        '11     111    11',\n        '11     11111 111',\n        '111111111111 111',\n    ],\n    symmetry: [1, 1],\n})\n\n\n\n\npresets.push({\n    name: 'office',\n    layout: [\n        '1111111111111111',\n        '1           1   ',\n        '1           1   ',\n        '11111111 1111   ',\n        '1     1     1   ',\n        '1     1     1   ',\n        '1               ',\n        '1     1     1   ',\n        '1     11111111 1',\n        '1     1   1     ',\n        '1         1     ',\n        '1     1   1     ',\n        '11 11111111     ',\n        '1   1     1     ',\n        '1   1     1     ',\n        '1   1     1     ',\n    ],\n    symmetry: [1, 1],\n})\n\n\n\npresets.push({\n    name: 'office-sym-baked',\n    layout: [\n        '       1     ',\n        '       1     ',\n        ' 111111111111',\n        '    1     1  ',\n        '    1     1  ',\n        '          1  ',\n        '    1     1  ',\n        '    1     1  ',\n        '11111     1111',\n        '1            ',\n        '1            ',\n        '1            ',\n        '1            ',\n        '11111     111',\n        '    1     1  ',\n        '    1     1  ',\n        '          1  ',\n        '    1     1  ',\n        '    1     1  ',\n        '1111111111111',\n        '       1     ',\n        '       1     ',\n    ],\n    symmetry: [0, 0],\n})\n\n\n\n\npresets.push({\n    name: 'plants',\n    layout: [\n        '                            ',\n        '                       3    ',\n        '                  3   323   ',\n        '            3    323   3    ',\n        '    3      323    3    2    ',\n        '   323      3     2   22    ',\n        '    3       2     22 22     ',\n        '    2      22      222      ',\n        '   22     22        2       ',\n        '   2      2         22      ',\n        '   22     2     3    22     ',\n        '    22   22    323   2      ',\n        '     22 22      3   22      ',\n        '      222       22 22       ',\n        '       2         222        ',\n        '       2          2         ',\n        '1111111111111111111111111111',\n    ],\n    colors: [[255, 255, 255], [0, 0, 0], [0, 128, 0], [255, 0, 0],],\n    symmetry: [1, 1],\n    edges: 'clamp',\n})\n\n\n\n\n\n\n\n\n\n/*\n * \n * \n *      normalize / process / export\n * \n * \n*/\n\n\nvar processed = presets.map(pre => {\n    var sx = pre.layout[0].length\n    var sy = pre.layout.length\n    var normed = []\n    pre.layout.join('').split('').forEach(char => {\n        if (!normed.includes(char)) normed.push(char)\n    })\n    normed.sort()\n\n    var data = new ndarray__WEBPACK_IMPORTED_MODULE_0__([], [sx, sy])\n    Object(_src_util__WEBPACK_IMPORTED_MODULE_1__[\"iterate2D\"])(data, (i, j) => {\n        var char = pre.layout[j][i]\n        data.set(i, j, normed.indexOf(char))\n    })\n    return {\n        name: pre.name || '~~~UNKNOWN~~~',\n        data: data,\n        colors: pre.colors || null,\n        symmetry: pre.symmetry || [0, 0],\n        edges: pre.edges || 'wrap',\n    }\n})\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (processed);\n\n\n\n//# sourceURL=webpack:///../demo/presets.js?");

/***/ }),

/***/ "../demo/ui.js":
/*!*********************!*\
  !*** ../demo/ui.js ***!
  \*********************/
/*! exports provided: initPresetNames, initOutputSize, setRules, setColors, setSymmetry, setEdges, drawImage, updatePixel, log, listen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initPresetNames\", function() { return initPresetNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initOutputSize\", function() { return initOutputSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setRules\", function() { return setRules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setColors\", function() { return setColors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setSymmetry\", function() { return setSymmetry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setEdges\", function() { return setEdges; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"drawImage\", function() { return drawImage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updatePixel\", function() { return updatePixel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"log\", function() { return log; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"listen\", function() { return listen; });\n/* harmony import */ var _imageView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageView */ \"../demo/imageView.js\");\n/* harmony import */ var _clickGridView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clickGridView */ \"../demo/clickGridView.js\");\n\n\n\n\n\n\n/*\n * \n * HTML elements and related managers\n * \n*/\n\nvar presets = document.getElementById('input-presets')\nvar xSymmetry = document.getElementById('input-xsym')\nvar ySymmetry = document.getElementById('input-ysym')\nvar edges = document.getElementById('input-edges')\nvar propDepth = document.getElementById('prop-depth')\n\nvar outSize = document.getElementById('output-size')\nvar outSizeNum = document.getElementById('output-size-n')\nvar xFilterSym = document.getElementById('filter-xsym')\nvar yFilterSym = document.getElementById('filter-ysym')\n\nvar solve = document.getElementById('but-solve')\nvar step = document.getElementById('but-step')\nvar anim = document.getElementById('but-anim')\nvar steps = document.getElementById('anim-steps')\nvar stepsNum = document.getElementById('anim-steps-n')\n\n\nvar inputView = new _imageView__WEBPACK_IMPORTED_MODULE_0__[\"default\"](document.getElementById('input'))\nvar outputView = new _imageView__WEBPACK_IMPORTED_MODULE_0__[\"default\"](document.getElementById('output'))\nvar filteredView = new _imageView__WEBPACK_IMPORTED_MODULE_0__[\"default\"](document.getElementById('filtered'))\nvar filteredOutView = new _imageView__WEBPACK_IMPORTED_MODULE_0__[\"default\"](document.getElementById('filtered-out'))\nvar getView = type => {\n    if (type === 'input') return inputView\n    if (type === 'output') return outputView\n    if (type === 'filtered') return filteredView\n    if (type === 'filtered-out') return filteredOutView\n    throw '?'\n}\n\nvar ruleGrid = new _clickGridView__WEBPACK_IMPORTED_MODULE_1__[\"default\"](document.getElementById('synth-rules'))\nvar filtGrid = new _clickGridView__WEBPACK_IMPORTED_MODULE_1__[\"default\"](document.getElementById('filter-rules'))\n\n\nfilteredView.displayScale = 0.6\nfilteredOutView.displayScale = 0.6\n\n\n\n\n/*\n * \n *      exported init / update functions\n * \n*/\n\nfunction initPresetNames(names) {\n    names.forEach(str => {\n        var opt = document.createElement('option')\n        opt.text = str\n        presets.add(opt)\n    })\n}\n\nfunction initOutputSize(s) {\n    outSize.value = s\n    outSizeNum.lastChild.textContent = ' ' + s\n}\n\nfunction setRules(list, filtList) {\n    ruleGrid.rules = list\n    ruleGrid.draw()\n    filtGrid.rules = filtList\n    filtGrid.draw()\n}\n\nfunction setColors(colors) {\n    inputView.colors = colors\n    outputView.colors = colors\n}\n\nfunction setSymmetry(arr) {\n    xSymmetry.checked = !!arr[0]\n    ySymmetry.checked = !!arr[1]\n}\n\nfunction setEdges(val) {\n    var opts = edges.options\n    for (var i = 0; i < opts.length; i++) {\n        if (val === opts[i].label) edges.selectedIndex = i\n    }\n}\n\nfunction drawImage(type, data) {\n    getView(type).drawData(data)\n}\n\nfunction updatePixel(type, i, j, weights) {\n    getView(type).updatePixel(i, j, weights)\n}\n\n\nfunction log(str) {\n    var area = document.getElementById('output-log')\n    area.value = str\n}\n\n\n\n\n\n\n\n/*\n * \n *      scaffolding for exported events\n * \n*/\n\nvar listeners = {}\nfunction listen(name, handler) {\n    listeners[name] = handler\n}\nfunction fireEvent(name, argArray) {\n    if (listeners[name]) listeners[name].apply(null, argArray)\n}\nvar checked = ev => ev.target.checked\nvar selIndex = ev => ev.target.selectedIndex\nvar selLabel = ev => ev.target.options[ev.target.selectedIndex].label\nvar numValue = ev => parseInt(ev.target.value)\n\n\n/*\n * \n *      fire events from UI elements\n * \n*/\n\npresets.onchange = ev => fireEvent('preset', [selIndex(ev)])\n\nxSymmetry.onchange = ev => fireEvent('xSymmetry', [checked(ev)])\nySymmetry.onchange = ev => fireEvent('ySymmetry', [checked(ev)])\nedges.onchange = ev => fireEvent('edges', [selLabel(ev)])\npropDepth.onchange = ev => fireEvent('propDepth', [selLabel(ev)])\n\nxFilterSym.onchange = ev => fireEvent('xFilterSym', [checked(ev)])\nyFilterSym.onchange = ev => fireEvent('yFilterSym', [checked(ev)])\n\noutSize.onchange = ev => fireEvent('size', [parseInt(outSize.value)])\n\nruleGrid.onChange = filtGrid.onChange = () => {\n    fireEvent('rules', [ruleGrid.rules, filtGrid.rules])\n}\n\n\n// display-only, set number values on slider change\noutSize.oninput = () => {\n    outSizeNum.lastChild.textContent = ' ' + outSize.value\n}\nsteps.oninput = () => {\n    stepsNum.lastChild.textContent = ' ' + steps.value\n}\n\n\n\n\n// solve/step/anim\nsolve.onclick = ev => fireEvent('solve')\nstep.onclick = ev => fireEvent('step')\nanim.onmousedown = ev => fireEvent('anim', [true])\nwindow.onmouseup = ev => fireEvent('anim', [false])\nsteps.onchange = ev => fireEvent('animSteps', [numValue(ev)])\n\n\n\n// misc action on canvas click or spacebar\n// document.querySelectorAll('canvas').forEach(el => {\n//     el.onclick = ev => fireEvent('misc')\n// })\ndocument.onkeydown = ev => {\n    if (ev.key !== ' ') return\n    fireEvent('misc')\n    ev.preventDefault()\n}\n\n\n\n//# sourceURL=webpack:///../demo/ui.js?");

/***/ }),

/***/ "../node_modules/iota-array/iota.js":
/*!******************************************!*\
  !*** ../node_modules/iota-array/iota.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota\n\n//# sourceURL=webpack:///../node_modules/iota-array/iota.js?");

/***/ }),

/***/ "../node_modules/is-buffer/index.js":
/*!******************************************!*\
  !*** ../node_modules/is-buffer/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n//# sourceURL=webpack:///../node_modules/is-buffer/index.js?");

/***/ }),

/***/ "../node_modules/ndarray/ndarray.js":
/*!******************************************!*\
  !*** ../node_modules/ndarray/ndarray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iota = __webpack_require__(/*! iota-array */ \"../node_modules/iota-array/iota.js\")\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"../node_modules/is-buffer/index.js\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n\n\n//# sourceURL=webpack:///../node_modules/ndarray/ndarray.js?");

/***/ }),

/***/ "../src/filterer.js":
/*!**************************!*\
  !*** ../src/filterer.js ***!
  \**************************/
/*! exports provided: Filterer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Filterer\", function() { return Filterer; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"../src/util.js\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ndarray */ \"../node_modules/ndarray/ndarray.js\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n\n\n\n\nfunction Filterer(input, output, rules, symmetry) {\n\n    if (!rules || rules.length === 0) {\n        // fallback to passing through inputs and doing no work\n        this.input = input\n        this.output = output\n        this.unfilter = () => { }\n        this.unfilterWeights = cts => cts\n        return\n    }\n\n\n    /*\n     * \n     *      create cloned input/output arrays\n     * \n    */\n\n    this.input = new ndarray__WEBPACK_IMPORTED_MODULE_1__([], input.shape)\n    this.output = new ndarray__WEBPACK_IMPORTED_MODULE_1__([], output.shape)\n    var fin = this.input\n    var fout = this.output\n\n\n    // filters input array and returns a defiltering lookup\n    var defilterLookup = filterInput(input, rules, fin, symmetry)\n    var numKeys = defilterLookup.reduce((a, v) => Math.max(a, v)) + 1\n\n    var keyCts = Array.from(Array(numKeys)).map(n => 0)\n\n\n\n    /*\n     * \n     *      expose APIs for getting unfiltered values/weights\n     * \n    */\n\n    this.unfilter = function (i, j) {\n        var val = fout.get(i, j)\n        output.set(i, j, defilterLookup[val])\n    }\n\n    this.unfilterWeights = function (cts) {\n        keyCts.forEach((n, i) => keyCts[i] = 0)\n        cts.forEach((ct, fk) => {\n            var k = defilterLookup[fk]\n            keyCts[k] += ct\n        })\n        return keyCts\n    }\n\n\n}\n\n\n\n\n\nfunction filterInput(arr, rules, filtArr, symmetry) {\n    // for now symmetery is [bool, bool, bool] => [x, y, rot]\n    var getVal = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"wrapArrayGetter\"])(arr, 'wrap', -1)\n    var keys = {}\n    var lookup = []\n\n    var makeKeyStr = (val, i, j, iflip, jflip, rot) => {\n        return rules.reduce((acc, offset) => {\n            var ri = (iflip) ? i - offset[0] : i + offset[0]\n            var rj = (jflip) ? j - offset[1] : j + offset[1]\n            var rval = (rot) ? getVal(rj, ri) : getVal(ri, rj)\n            return acc + ':' + rval\n        }, val)\n    }\n\n    Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"iterate2D\"])(arr, (i, j) => {\n        var val = arr.get(i, j)\n        var found = ''\n        var keystr = makeKeyStr(val, i, j, 0, 0, 0)\n        if (keys[keystr]) found = keystr\n        if (!found && symmetry[0]) {\n            var strx = makeKeyStr(val, i, j, 1, 0, 0)\n            if (keys[strx]) found = strx\n        }\n        if (!found && symmetry[1]) {\n            var stry = makeKeyStr(val, i, j, 0, 1, 0)\n            if (keys[stry]) found = stry\n        }\n        if (!found && symmetry[0] && symmetry[1]) {\n            var strxy = makeKeyStr(val, i, j, 1, 1, 0)\n            if (keys[strxy]) found = strxy\n        }\n        if (!found && symmetry[2]) {\n\n            // need to think about rotation case...\n\n        }\n        if (!found) {\n            lookup.push(val)\n            keys[keystr] = lookup.length\n            found = keystr\n        }\n        var fval = keys[found] - 1\n        filtArr.set(i, j, fval)\n    })\n    return lookup\n}\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///../src/filterer.js?");

/***/ }),

/***/ "../src/index.js":
/*!***********************!*\
  !*** ../src/index.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _markSynth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./markSynth */ \"../src/markSynth.js\");\n/* harmony import */ var _filterer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filterer */ \"../src/filterer.js\");\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (FilteredSynth);\n\n\n\n\nfunction FilteredSynth(input, output, rules, options) {\n\n    var opts = Object.assign({}, {\n        symmetry: [false, false],\n        edges: 'wrap',\n        propagateDepth: 1,\n        filterRules: null,\n        filterSymmetry: [false, false],\n    }, options)\n\n\n\n    // pre-synth filtering \n    var filt = new _filterer__WEBPACK_IMPORTED_MODULE_1__[\"Filterer\"](input, output, opts.filterRules, opts.filterSymmetry)\n\n\n    // synth gets cloned filtered input/output arrays\n    var markSynth = new _markSynth__WEBPACK_IMPORTED_MODULE_0__[\"default\"](filt.input, filt.output, rules, opts)\n\n\n    // use internal synth to keep unfiltered output current\n    markSynth.onObserve = (i, j) => filt.unfilter(i, j)\n\n\n\n    /*\n     * \n     *      just wrap all other synth APIs\n     * \n    */\n\n    this.done = false\n\n    this.reset = function () {\n        markSynth.reset()\n        this.done = markSynth.done\n    }\n\n    this.iterate = function () {\n        markSynth.iterate()\n        this.done = markSynth.done\n    }\n\n    this.getNodeWeights = function (i, j) {\n        var wts = markSynth.getNodeWeights(i, j)\n        return filt.unfilterWeights(wts)\n    }\n\n\n\n\n\n    /*\n     * \n     *      expose some internals for testing\n     * \n    */\n\n    this.filteredInput = filt.input\n    this.filteredOutput = filt.output\n    this.getFilteredNodeWeights = markSynth.getNodeWeights\n\n}\n\n\n\n\n\n//# sourceURL=webpack:///../src/index.js?");

/***/ }),

/***/ "../src/markSynth.js":
/*!***************************!*\
  !*** ../src/markSynth.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ndarray */ \"../node_modules/ndarray/ndarray.js\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"../src/util.js\");\n/* harmony import */ var _pqueue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pqueue */ \"../src/pqueue.js\");\n/* harmony import */ var _statBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./statBuilder */ \"../src/statBuilder.js\");\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MarkSynth);\n\nvar PROFILE = 1\nvar REPORT = 0 // 0..3\n\n\n\n\n\n/*\n * \n * \n *      basic \"frequency of neighbor values\" synthesizer\n * \n *      note: assumes values in \"input\" ndarray are \n *      normalized into 0...(nk-1) with no gaps\n * \n * \n*/\n\n\n\n\n/*\n * \n *      core and API\n * \n*/\n\nfunction MarkSynth(input, output, rules, options) {\n\n    var opts = Object.assign({}, {\n        symmetry: [false, false],\n        edges: 'wrap',\n        propagateDepth: 1,\n    }, options)\n\n\n    // console.log('new synth: ',\n    //     input.shape.join(','), '->', output.shape.join(','),\n    //     '  symm [' + options.symmetry.join(',') + ']',\n    //     '  edges', options.edges,\n    //     '  depth', options.propagateDepth,\n    // )\n\n\n\n\n\n    /*\n     * \n     * \n     *      inputs and stats and rules setup\n     * \n     * \n    */\n\n    // first declare nodes ndarray and make wrapped accessor\n    // this is needed early so that stats can bind to it\n    var nodes = new ndarray__WEBPACK_IMPORTED_MODULE_0__([], output.shape)\n    var getNode = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"wrapArrayGetter\"])(nodes, opts.edges, null)\n\n\n    // stat builder creates stats for the input,\n    // provides an iterator for stats related to each rule\n    var stats = Object(_statBuilder__WEBPACK_IMPORTED_MODULE_3__[\"buildStats\"])(input, rules, getNode, opts)\n    var keys = stats.counts.map((ct, i) => i)\n    var baseCounts = stats.counts.map(k => k | 0)\n    var baseEntropy = entropyFromCounts(baseCounts)\n    var OOB = stats.oobValue | 0\n    var iterateRules = stats.iterateRules\n\n\n\n\n\n\n\n\n\n\n    /* \n     * \n     *      Internal state init\n     * \n    */\n\n    var nodeQueue\n    var numObserved\n    var observeList\n    var propagateList\n\n    function Node(i, j) {\n        this.i = i\n        this.j = j\n        this.val = -2\n        this.cts = null\n        this.entropy = 0.5\n    }\n\n    this.reset = function () {\n        // console.clear()\n        Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"iterate2D\"])(nodes, (i, j) => {\n            nodes.set(i, j, null)\n            var node = new Node(i, j)\n            node.cts = baseCounts.slice()\n            node.entropy = baseEntropy\n            nodes.set(i, j, node)\n        })\n        nodeQueue = new _pqueue__WEBPACK_IMPORTED_MODULE_2__[\"PQueue\"]()\n        // nodeQueue.add(getNode(3, 3))\n        propagateList = []\n        observeList = []\n        numObserved = 0\n        this.done = false\n        if (opts.edges === 'clamp') applyEdgeClampEffect()\n    }\n    this.reset()\n\n\n\n\n\n\n\n\n    /*\n     * \n     * \n     *          core loop\n     * \n     * \n    */\n\n    this.done = false\n\n    this.iterate = function () {\n        profile('start')\n\n        var node = findLowestEntropyNode()\n        if (node) observeList.push(node)\n        profile('find')\n\n        while (observeList.length > 0) {\n            var obs = observeList.pop()\n            observe(obs)\n            this.onObserve(obs.i, obs.j)\n            profile('observe')\n\n            doPropagate()\n        }\n\n        if (numObserved === nodes.data.length) this.done = true\n\n        profile('end')\n    }\n\n\n    // testing\n    this.getNodeWeights = function (i, j) {\n        var node = getNode(i, j)\n        return (node) ? node.cts : null\n    }\n\n    // also testing\n    this.onObserve = function (i, j) {\n        // override from parent if needed\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /* \n     * \n     *      Update functions\n     * \n    */\n\n\n    function findLowestEntropyNode() {\n        // get from pqueue, redo if result is already observed\n        var node = nodeQueue.get()\n        while (node && node.val >= 0) node = nodeQueue.get()\n        if (node) return node\n\n        // finished?\n        var nodeCt = nodes.data.length\n        if (numObserved === nodeCt) return null\n\n        // if pqueue is empty, all unobserved nodes have \n        // never been updated, so just pick a random one\n        var off = (Math.random() * nodeCt) | 0\n        for (var i = 0; i < nodeCt; i++) {\n            var n = nodes.data[(i + off) % nodeCt]\n            if (n.val < 0) return n\n        }\n        throw 'Internal bug - not finished but no unobserved nodes found?'\n    }\n\n\n\n    function observe(node) {\n        if (node.val >= 0) return // node got into observe list twice\n        numObserved++\n        // choose value and update node (val = numKeys if no options)\n        var val = chooseFromCounts(node.cts)\n        if (val < 0) val = keys.length\n        report_hook(1, node, val)\n        node.val = val\n        node.entropy = 0\n        // reset counts\n        keys.forEach(k => { node.cts[k] = 0 })\n        node.cts[val] = baseCounts[val]\n        output.set(node.i, node.j, val)\n        // propagate (unless no valid option was found)\n        if (val < keys.length) propagateList.push(node)\n    }\n\n\n\n\n    function doPropagate() {\n        var depth = 1\n        while (propagateList.length > 0) {\n            // make a new list and propagate everything in the old one\n            var curr = propagateList\n            propagateList = []\n            curr.forEach((n) => propagateFrom(n, depth))\n            profile('propagate' + depth)\n            if (++depth > opts.propagateDepth) break\n        }\n        propagateList = []\n    }\n\n\n\n\n    function propagateFrom(node, depth) {\n        report_hook(2, node, depth)\n        // simpler update logic when propagating from observed node\n        var update = (node.val >= 0) ?\n            updateFromClosedNode :\n            updateFromOpenNode\n        iterateRules(node.i, node.j, (nab, getStat) => {\n            if (!nab) return // out of bounds\n            if (nab.val >= 0) return // never propagate to observed node\n            var changed = update(node, nab, getStat)\n            if (changed) {\n                var ent = entropyFromCounts(nab.cts)\n                report_hook(3, nab, ent)\n                nab.entropy = ent\n                if (!nodeQueue.has(nab)) nodeQueue.add(nab)\n                if (nab.entropy === 0) {\n                    observeList.push(nab)\n                } else {\n                    if (!propagateList.includes(nab)) {\n                        propagateList.push(nab)\n                    }\n                }\n            }\n        })\n    }\n\n\n\n    function updateFromClosedNode(node, nab, getStat) {\n        var changed = false\n        var k1 = node.val\n        keys.forEach(k2 => {\n            var stat = getStat(k1, k2)\n            if (stat < nab.cts[k2]) {\n                nab.cts[k2] = stat\n                changed = true\n            }\n        })\n        return changed\n    }\n\n    function updateFromOpenNode(node, nab, getStat) {\n        var changed = false\n        keys.forEach(k2 => {\n            // sum up messages about neighbor being key = k2\n            var ct = keys.reduce((sum, k1) => {\n                var ct = node.cts[k1]\n                if (ct === 0) return sum\n                return sum + getStat(k1, k2)\n            }, 0)\n            if (ct < nab.cts[k2]) {\n                nab.cts[k2] = ct\n                changed = true\n            }\n        })\n        if (changed) nab.entropy = entropyFromCounts(nab.cts)\n        return changed\n    }\n\n\n\n\n\n    //      edge case (heh)\n    function applyEdgeClampEffect() {\n        // propagate once from OOB nodes to apply edge effect \n        var si = output.shape[0]\n        var sj = output.shape[1]\n\n        var edgeNode = new Node(0, 0)\n        edgeNode.val = OOB\n        edgeNode.entropy = 0\n        edgeNode.cts = keys.map(k => 0)\n\n        for (var i = -1; i <= si; i++) {\n            edgeNode.i = i\n            edgeNode.j = -1\n            propagateFrom(edgeNode, 0)\n            edgeNode.j = sj\n            propagateFrom(edgeNode, 0)\n        }\n        for (var j = -1; j <= sj; j++) {\n            edgeNode.j = j\n            edgeNode.i = -1\n            propagateFrom(edgeNode, 0)\n            edgeNode.i = si\n            propagateFrom(edgeNode, 0)\n        }\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n * \n *      helpers\n * \n*/\n\n\nfunction entropyFromCounts(cts) {\n    var sum = cts.reduce((acc, val) => acc + val, 0)\n    if (sum === 0) return 1000\n    var max = cts.reduce((acc, val) => Math.max(acc, val))\n    return cts.reduce((acc, v) => {\n        var p = v / sum\n        if (p === 0) return acc\n        return acc - p * Math.log2(p)\n    }, 0) * (1 + max * 0.00001)\n}\n\n\nfunction chooseFromCounts(arr) {\n    // [5, 4, 1] => 40% chance of `1`, etc.\n    var total = arr.reduce((accum, val) => accum + val, 0)\n    if (total === 0) return -1\n    var n = total * Math.random()\n    var i = 0\n    while (n > 0) { n -= arr[i++] }\n    return i - 1\n}\n\n\nfunction logNode(node) {\n    return [\n        `(${node.i},${node.j}`,\n        `[${node.cts.join(',')}]`,\n        `e=${Math.round(node.entropy * 100000) / 100000}`,\n        `v=${node.val})`,\n    ].join(' ')\n}\n\n\n\n\n\nvar profile = () => { }\nif (PROFILE) profile = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"makeTimer\"])(5000, 'mark synth')\n\nvar report_hook = () => { }\nif (REPORT) report_hook = function (num, node, arg) {\n    if (num > REPORT) return\n    if (num === 1) console.log('observe:', logNode(node), 'val -->', arg)\n    if (num === 2) console.log('  propagate:', 'D=' + arg, logNode(node))\n    if (num === 3) console.log('    updated:', logNode(node), 'ent -->', arg)\n}\n\n\n\n//# sourceURL=webpack:///../src/markSynth.js?");

/***/ }),

/***/ "../src/pqueue.js":
/*!************************!*\
  !*** ../src/pqueue.js ***!
  \************************/
/*! exports provided: PQueue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PQueue\", function() { return PQueue; });\n\n\n/*\n * \n *      incredibly naive p-queue\n * \n*/\n\nfunction PQueue() {\n\n    var list = []\n\n    this.add = function (node) {\n        list.push(node)\n    }\n\n    this.has = function (node) {\n        return list.includes(node)\n    }\n\n    this.get = function () {\n        var i = minIndex(list)\n        if (i < 0) return null\n        return fastSplice(list, i)\n    }\n\n}\n\n\n\n\nfunction minIndex(arr) {\n    var minE = 999999\n    var minI = -1\n    for (var i = 0; i < arr.length; i++) {\n        var e = arr[i].entropy\n        // assume 0 is absolute minimum\n        if (e === 0) return i\n        if (e < minE) { minE = e; minI = i }\n    }\n    return minI\n}\n\n\nfunction fastSplice(arr, i) {\n    if (i === arr.length - 1) return arr.pop()\n    var tmp = arr[i]\n    arr[i] = arr.pop()\n    return tmp\n}\n\n\n\n\n\n\n// var q = new PQueue()\n// var e = { entropy: 1 }\n// q.add(e)\n// q.add({ entropy: 0 })\n// q.add({ entropy: 3 })\n// q.add({ entropy: 2 })\n// if (!q.has(e)) throw 'yo'\n// if (q.get().entropy !== 0) throw 'yo'\n// if (q.get().entropy !== 1) throw 'yo'\n// if (q.get().entropy !== 2) throw 'yo'\n// if (q.get().entropy !== 3) throw 'yo'\n// if (q.get() !== null) throw 'yo'\n\n\n//# sourceURL=webpack:///../src/pqueue.js?");

/***/ }),

/***/ "../src/statBuilder.js":
/*!*****************************!*\
  !*** ../src/statBuilder.js ***!
  \*****************************/
/*! exports provided: buildStats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildStats\", function() { return buildStats; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"../src/util.js\");\n\n\n\n\n\nfunction buildStats(input, rules, getNode, options) {\n\n    // prelims\n    var numKeys = input.data.reduce((acc, val) => Math.max(acc, val)) + 1\n    var keys = Array.from(Array(numKeys)).map((v, i) => i)\n    var symmetry = options.symmetry || [false, false]\n\n    // aribtrary key value for \"out of bounds\"\n    var OOB = numKeys + 10\n\n    // conform stuff\n    rules = conformRules(rules)\n    var getInput = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"wrapArrayGetter\"])(input, options.edges, -1)\n\n    // create data storage and getters\n    var data = {}\n    var addStat = (ruleNum, k1, k2) => {\n        var str = `${ruleNum}:${k1}:${k2}`\n        data[str] = (data[str] || 0) + 1\n    }\n    var statGetters = rules.map((off, ruleNum) => {\n        return (k1, k2) => data[`${ruleNum}:${k1}:${k2}`] || 0\n    })\n\n    // wrap addStat to handle edge modes\n    var safeAddStat = (function () {\n        if (options.edges === 'wrap') return addStat\n        if (options.edges === 'clamp') return (ruleNum, k1, k2) => {\n            addStat(ruleNum, k1, (k2 < 0 ? OOB : k2))\n        }\n        if (options.edges === 'ignore') return (ruleNum, k1, k2) => {\n            if (k2 < 0) return\n            addStat(ruleNum, k1, k2)\n        }\n        throw 'Unknown edges mode: ' + options.edges\n    })()\n\n\n    // build the stat data\n    var counts = keys.map(k => 0)\n    Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"iterate2D\"])(input, (i, j) => {\n        var k1 = input.get(i, j)\n        counts[k1]++\n        rules.forEach((offset, ruleNum) => {\n\n            // stat for raw offset\n            var k2 = getInput(i + offset[0], j + offset[1])\n            safeAddStat(ruleNum, k1, k2)\n\n            // horizontal symmetry?\n            if (symmetry[0] && (offset[0] !== 0)) {\n                var k3 = getInput(i - offset[0], j + offset[1])\n                safeAddStat(ruleNum, k1, k3)\n            }\n\n            // vertical symmetry?\n            if (symmetry[1] && (offset[1] !== 0)) {\n                var k4 = getInput(i + offset[0], j - offset[1])\n                safeAddStat(ruleNum, k1, k4)\n            }\n        })\n    })\n\n    // in clamp mode, add stats for a theoretical outer edge row\n    if (options.edges === 'clamp') (function () {\n        var si = input.shape[0]\n        var sj = input.shape[1]\n        var addFromEdge = (i, j) => {\n            rules.forEach((offset, ruleNum) => {\n                var k2 = getInput(i + offset[0], j + offset[1])\n                if (k2 >= 0) addStat(ruleNum, OOB, k2)\n            })\n        }\n        for (var i = -1; i <= si; i++) {\n            addFromEdge(i, -1)\n            addFromEdge(i, sj)\n        }\n        for (var j = -1; j <= sj; j++) {\n            addFromEdge(-1, j)\n            addFromEdge(si, j)\n        }\n    })()\n\n\n    // build rule iterator\n    var iterateRules = (i, j, cb) => {\n        rules.forEach((offset, ruleNum) => {\n            var nab = getNode(i + offset[0], j + offset[1])\n            if (nab) cb(nab, statGetters[ruleNum])\n        })\n    }\n\n    // console.log('DATA DUMP')\n    // Object.keys(data).sort().forEach(k => {\n    //     console.log(k, data[k])\n    // })\n\n    // exports\n    return {\n        numKeys: numKeys,\n        oobValue: OOB,\n        counts: counts,\n        iterateRules: iterateRules,\n    }\n}\n\n\n\n\n\n/*\n * \n * \n *          rule offset wrangling\n * \n * \n*/\n\nfunction conformRules(rules) {\n    rules = rules || []\n\n    // filter to unique elements\n    var found = {}\n    return rules.filter(off => {\n        var s = off.join(',')\n        if (found[s]) return false\n        found[s] = 1\n        return true\n    })\n}\n\n\n\n\n\n\n//# sourceURL=webpack:///../src/statBuilder.js?");

/***/ }),

/***/ "../src/util.js":
/*!**********************!*\
  !*** ../src/util.js ***!
  \**********************/
/*! exports provided: iterate2D, wrapArrayGetter, makeTimer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"iterate2D\", function() { return iterate2D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrapArrayGetter\", function() { return wrapArrayGetter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeTimer\", function() { return makeTimer; });\n\n\n\n\nfunction iterate2D(array, cb) {\n    var si = array.shape[0]\n    var sj = array.shape[1]\n    for (var j = 0; j < sj; j++) {\n        for (var i = 0; i < si; i++) cb(i, j, si, sj)\n    }\n}\n\n\n\nfunction wrapArrayGetter(arr, mode, oobValue) {\n    var si = arr.shape[0]\n    var sj = arr.shape[1]\n    if (mode === 'wrap') return function (i, j) {\n        if (i < 0) { i += si } else if (i >= si) { i -= si }\n        if (j < 0) { j += sj } else if (j >= sj) { j -= sj }\n        return arr.get(i, j)\n    }\n    return function (i, j) {\n        if (i < 0 || i >= si) return oobValue\n        if (j < 0 || j >= sj) return oobValue\n        return arr.get(i, j)\n    }\n}\n\n\n\n\nfunction makeTimer(every, title, logFn) {\n    if (!title) title = 'timer'\n    if (!every || isNaN(every)) every = 1\n    var times = {}\n    var counts = {}\n    var last = 0\n    var calls = 0\n    return function (activity) {\n        if (activity === 'start') {\n            // start a new entry\n            last = performance.now()\n            calls++\n        } else if (activity !== 'end') {\n            // add time for an activity\n            var now = performance.now()\n            counts[activity] = (counts[activity] || 0) + 1\n            times[activity] = (times[activity] || 0) + now - last\n            last = now\n        } else {\n            // finish and report if needed\n            if (calls < every) return\n            var strs = Object.keys(counts).map(act => {\n                var avg = times[act]\n                var digits = (avg < 0) ? 2 : (avg < 10) ? 1 : 0\n                return `${act}: ${avg.toFixed(digits)}ms`\n            })\n            var suffix = (every > 1) ? `  (total over ${calls} calls)` : ''\n            var out = `${title}:  ${strs.join('  ')}${suffix}`\n            if (logFn) {\n                logFn(out.split('  ').join('\\n  '))\n            } else console.log(out)\n            times = {}\n            counts = {}\n            calls = 0\n        }\n    }\n}\n\n\n\n\n\n//# sourceURL=webpack:///../src/util.js?");

/***/ })

/******/ });